#ifndef csalmon_vm_h
#define csalmon_vm_h

#include "chunk.h"
#include "table.h"
#include "value.h"

// 给我们的虚拟机一个固定的栈大小，意味着某些指令系列可能会压入太多的值并耗尽栈空间——典型的“堆栈溢出”。
#define STACK_MAX 256

// 虚拟机是我们解释器内部结构的一部分。你把一个代码块交给它，它就会运行这块代码。VM的代码和数据结构放在一个新的模块中。
typedef struct {
	Chunk* chunk;
	// 当虚拟机运行字节码时，它会记录它在哪里——即当前执行的指令所在的位置。
	// 我们没有在run()方法中使用局部变量来进行记录，因为最终其它函数也会访问该值。
	// “IP”这个名字很传统，而且与CS中的很多传统名称不同的是，它是有实际意义的：它是一个指令指针。
	// 几乎世界上所有的指令集，不管是真实的还是虚拟的，都有一个类似的寄存器或变量。
	uint8_t* ip;
	// 在基于堆栈的虚拟机中执行指令是非常简单的。在后面的章节中，你还会发现，将源语言编译成基于栈的指令集是小菜一碟。
	// 但是，这种架构的速度快到足以在产生式语言的实现中使用。这感觉就像是在编程语言游戏中作弊。
	Value stack[STACK_MAX];
	Value* stackTop;
	// 我们需要一个地方来存储这些全局变量。因为我们希望它们在clox运行期间一直存在，所以我们将它们之间存储在虚拟机中。
	Table globals;
	// 我们将使用一种叫作字符串驻留的技术，核心问题是，在内存中不同的字符串可能包含相同的字符。
	// 尽管它们是不同的对象，它们的行为也需要像等效值一样。它们本质上是相同的，而我们必须比较它们所有的字节来检查这一点。
	// 字符串驻留是一个数据去重的过程。
	// 我们创建一个“驻留”字符串的集合。该集合中的任何字符串都保证与其它字符串在文本上不相同。
	// 当你要驻留一个字符串时，首先从集合中查找匹配的字符串，如果找到了，就使用原来的那个。
	// 否则，说明你持有的字符串是唯一的，所以你将其添加到集合中。
	// 通过这种方式，你知道每个字符序列在内存中只由一个字符串表示。
	// 这使得值相等变得很简单。如果两个字符串在内存中指向相同的地址，它们显然是同一个字符串，并且必须相等。
	// 为了可靠地去重所有字符串，虚拟机需要能够找到创建的每个字符串。我们用一个哈希表存储这些字符串，从而实现这一点。
	Table strings;
	// VM存储一个指向表头的指针。
	Obj* objects;
} VM;

// 当我们有一个报告静态错误的编译器和检测运行时错误的VM时，解释器会通过它来知道如何设置进程的退出代码。
typedef enum {
	INTERPRET_OK,
	INTERPRET_COMPILE_ERROR,
	INTERPRET_RUNTIME_ERROR
} InterpretResult;

// “object”模块直接使用了“vm”模块的vm变量，所以我们需要将该变量公开到外部。
extern VM vm;

// VM会逐步获取到一大堆它需要跟踪的状态，所以我们现在定义一个结构，把这些状态都塞进去。
void initVM();
void freeVM();
// 我们已经得到了Lox源代码字符串，所以现在我们准备建立一个管道来扫描、编译和执行它。管道是由interpret()驱动的。
InterpretResult interpret(const char* source);

void push(Value value);
Value pop();

#endif